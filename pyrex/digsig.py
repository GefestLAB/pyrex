"""Module containing classes for digital signal processing"""


import numpy as np
import scipy.signal

class Signal:
    """Base class for signals. Takes arrays of times and values
    (values array forced to size of times array by zero padding or slicing).
    Supports adding between signals with the same time values,
    resampling the signal, and calculating the signal's envelope."""
    def __init__(self, times, values):
        self.times = np.array(times)
        len_diff = len(times)-len(values)
        if len_diff>0:
            self.values = np.concatenate((values, np.zeros(len_diff)))
        else:
            self.values = np.array(values[:len(times)])

    def __add__(self, other):
        """Adds two signals by adding their values at each time."""
        if not(isinstance(other, Signal)):
            raise TypeError("Can't add object with type"
                            +str(type(other))+" to a signal")
        if not(np.array_equal(self.times, other.times)):
            raise ValueError("Can't add signals with different times")
        
        return Signal(self.times,self.values+other.values)

    def __radd__(self, other):
        """Allows for adding Signal object to 0.
        Useful when using sum() on a set of signals."""
        if other!=0:
            raise TypeError("unsupported operand type(s) for +: '"+
                            +str(type(other))+"' and 'Signal'")

        return self

    @property
    def dt(self):
        """Returns the spacing of the time array, or None if invalid."""
        try:
            return self.times[1]-self.times[0]
        except IndexError:
            return None

    @property
    def envelope(self):
        """Calculates envelope of the signal by Hilbert transform."""
        analytic_signal = scipy.signal.hilbert(self.values)
        return np.abs(analytic_signal)

    def resample(self, n):
        """Resamples the signal into n points in the same time range"""
        if n==len(self.times):
            return

        self.times = np.linspace(self.times[0], self.times[-1], n)
        self.values = scipy.signal.resample(self.values, n)



class EmptySignal(Signal):
    """Class for signal with no amplitude (all values = 0)"""
    def __init__(self, times):
        super().__init__(times, np.zeros(len(times)))


class FunctionSignal(Signal):
    """Class for signals generated by a function"""
    def __init__(self, times, function):
        self.function = function
        values = []
        for t in times:
            values.append(self.function(t))
        super().__init__(times, values)



class SlowAskaryanSignal(Signal):
    """Askaryan pulse binned to times from neutrino with given energy (TeV)
    observed at angle theta (radians). Optional parameters are the index of
    refraction n, and pulse offset to start time t0 (s).\n
    Note that the amplitude of the pulse goes as 1/R, where R is the distance
    from source to observer. R is assumed to be 1 meter so that dividing by a
    different value produces the proper result."""
    def __init__(self, times, energy, theta, n=1.78, t0=0):
        self.energy = energy
        self.vec_pot = np.zeros(len(times))

        # Calculation of pulse based on https://arxiv.org/pdf/1106.6283v3.pdf
        # Vector potential is given by:
        #   A(theta,t) = integral(Q(z) * RAC(t-z(1-n*cos(theta))/c))
        #                * sin(theta) / sin(theta_c) / R / integral(Q(z))

        # Conversion factor for z in RAC
        z_to_t = (1 - n*np.cos(theta))/3e8

        # Integrals of z go from z_min to z_max with n_z steps
        z_min = 0
        z_max = 2.5*self.max_length()
        n_z = 1000
        z_vals, dz = np.linspace(z_min, z_max, n_z, endpoint=False, retstep=True)

        # Q(z) is the same for every time
        Q = np.zeros(n_z)
        for i, z in enumerate(z_vals):
            Q[i] = self.charge_profile(z)
        
        # Calculate RAC and integral(Q*RAC) at each time
        for i, t in enumerate(times):
            RA_C = np.zeros(n_z)
            for j, z in enumerate(z_vals):
                RA_C[j] = self.RAC(t - t0 - z*z_to_t)
            self.vec_pot[i] = np.trapz(Q*RA_C, dx=dz)

        # Calculate LQ_tot (the excess longitudinal charge along the shower)
        LQ_tot = np.trapz(Q, dx=dz)

        # Calculate sin(theta_c) = sqrt(1-cos^2(theta_c)) = sqrt(1-1/n^2)
        sin_theta_c = np.sqrt(1 - 1/n**2)

        # Scale the integral by the necessary factors
        self.vec_pot *= np.sin(theta) / sin_theta_c / LQ_tot

        # Calculate electric field by taking derivative of vector potential
        dt = times[1] - times[0]
        values = -np.diff(self.vec_pot) / dt
        # values = -np.diff(self.vec_pot)) / np.sqrt(dt)
        # preserves pulse size for changes in dt

        super().__init__(times, values)


    def RAC(self, time):
        """Calculates R * vector potential at the Cherenkov angle in Vs
        at the given time (s)."""
        # Get absolute value of time in nanoseconds
        ta = np.abs(time) * 1e9
        if time>=0:
            return (-4.5e-14 * self.energy
                    * (np.exp(-ta/0.057) + (1+2.87*ta)**-3))
        else:
            return (-4.5e-14 * self.energy
                    * (np.exp(-ta/0.030) + (1+3.05*ta)**-3.5))

    def charge_profile(self, z, density=0.92, crit_energy=7.86e-5,
                       rad_length=36.08):
        """Calculates the longitudinal charge profile in the EM shower at
        distance z (m) with parameters for the density (g/cm^3),
        critical energy (TeV), and electron radiation length (g/cm^2) in ice."""
        if z<=0 or self.energy<=crit_energy:
            return 0

        # Depth calculated by "integrating" the density along the shower path
        # (in g/cm^2)
        x = 100 * z * density
        x_ratio = x / rad_length
        e_ratio = self.energy / crit_energy

        # Shower age
        s = 3 * x_ratio / (x_ratio + 2*np.log(e_ratio))

        # Number of particles
        N = (0.31 * np.exp(x_ratio * (1 - 1.5*np.log(s)))
             / np.sqrt(np.log(e_ratio)))

        return N * 1.602e-19

    def max_length(self, density=0.92, crit_energy=7.86e-5, rad_length=36.08):
        """Calculates the maximum length (m) of an EM shower
        with parameters for the density (g/cm^3), critical energy (TeV), and
        electron radiation length (g/cm^2) in ice."""
        # Maximum depth in g/cm^2
        x_max = rad_length * np.log(self.energy / crit_energy) / np.log(2)

        return 0.01 * x_max / density


class FastAskaryanSignal(Signal):
    """Askaryan pulse binned to times from neutrino with given energy (TeV)
    observed at angle theta (radians). Optional parameters are the index of
    refraction n, and pulse offset to start time t0 (s).\n
    Note that the amplitude of the pulse goes as 1/R, where R is the distance
    from source to observer. R is assumed to be 1 meter so that dividing by a
    different value produces the proper result."""
    def __init__(self, times, energy, theta, n=1.78, t0=0):
        self.energy = energy

        # Calculation of pulse based on https://arxiv.org/pdf/1106.6283v3.pdf
        # Vector potential is given by:
        #   A(theta,t) = convolve(Q(z(1-n*cos(theta))/c)),RAC(z(1-n*cos(theta))/c))
        #                * sin(theta) / sin(theta_c) / R / integral(Q(z)) * c / (1-n*cos(theta))

        # Conversion factor for z in RAC
        z_to_t = (1 - n*np.cos(theta))/3e8

        dt = times[1] - times[0]
        dz = np.abs(dt / z_to_t)

        z_max = 2.5*self.max_length()
        n_Q = int(z_max/dz)
        z_Q_vals = np.arange(n_Q)
        z_Q_vals = z_Q_vals * dz
        Q = np.zeros(n_Q)
        for i, z in enumerate(z_Q_vals):
            Q[i] = self.charge_profile(z)

        n_RAC = len(times) + 1 - n_Q
        z_RAC_vals = np.arange(n_RAC)
        z_RAC_vals = z_RAC_vals * dz
        RA_C = np.zeros(n_RAC)
        for i, z in enumerate(z_RAC_vals):
            RA_C[i] = self.RAC(t0 + z*z_to_t)

        # Convolve Q and RAC
        self.vec_pot = scipy.signal.convolve(Q, RA_C, mode='full')

        # Calculate LQ_tot (the excess longitudinal charge along the shower)
        LQ_tot = np.trapz(Q, dx=dz)

        # Calculate sin(theta_c) = sqrt(1-cos^2(theta_c)) = sqrt(1-1/n^2)
        sin_theta_c = np.sqrt(1 - 1/n**2)

        # Scale the integral by the necessary factors
        self.vec_pot *= np.sin(theta) / sin_theta_c / LQ_tot / z_to_t

        # Calculate electric field by taking derivative of vector potential
        values = -np.diff(self.vec_pot) / dt
        # values = -np.diff(self.vec_pot)) / np.sqrt(dt)
        # preserves pulse size for changes in dt

        print(len(times))
        print(len(self.vec_pot))
        print(len(values))

        super().__init__(times, values)


    def RAC(self, time):
        """Calculates R * vector potential at the Cherenkov angle in Vs
        at the given time (s)."""
        # Get absolute value of time in nanoseconds
        ta = np.abs(time) * 1e9
        if time>=0:
            return (-4.5e-14 * self.energy
                    * (np.exp(-ta/0.057) + (1+2.87*ta)**-3))
        else:
            return (-4.5e-14 * self.energy
                    * (np.exp(-ta/0.030) + (1+3.05*ta)**-3.5))

    def charge_profile(self, z, density=0.92, crit_energy=7.86e-5,
                       rad_length=36.08):
        """Calculates the longitudinal charge profile in the EM shower at
        distance z (m) with parameters for the density (g/cm^3),
        critical energy (TeV), and electron radiation length (g/cm^2) in ice."""
        if z<=0 or self.energy<=crit_energy:
            return 0

        # Depth calculated by "integrating" the density along the shower path
        # (in g/cm^2)
        x = 100 * z * density
        x_ratio = x / rad_length
        e_ratio = self.energy / crit_energy

        # Shower age
        s = 3 * x_ratio / (x_ratio + 2*np.log(e_ratio))

        # Number of particles
        N = (0.31 * np.exp(x_ratio * (1 - 1.5*np.log(s)))
             / np.sqrt(np.log(e_ratio)))

        return N * 1.602e-19

    def max_length(self, density=0.92, crit_energy=7.86e-5, rad_length=36.08):
        """Calculates the maximum length (m) of an EM shower
        with parameters for the density (g/cm^3), critical energy (TeV), and
        electron radiation length (g/cm^2) in ice."""
        # Maximum depth in g/cm^2
        x_max = rad_length * np.log(self.energy / crit_energy) / np.log(2)

        return 0.01 * x_max / density


# Use the slow version of the askaryan signal for now until kinks are worked
# out of fast version
AskaryanSignal = SlowAskaryanSignal



class GaussianNoise(FunctionSignal):
    """Gaussian noise signal with standard deviation sigma"""
    def __init__(self, times, sigma):
        self.sigma = sigma
        super().__init__(times, lambda t: np.random.normal(0,self.sigma))
